char = "\u0000".."\U10FFFF"

alpha = "a".."z" | "A".."Z"

alphas = many(alpha)

lower = "a".."z"

lowers = many(lower)

upper = "A".."Z"

uppers = many(upper)

numeral = "0".."9"

numerals = many(numeral)

space = " " | "\t"

spaces = many(space)

newline = "\n" | "\r\n"

newlines = many(newline)

nl = newline

# end_of_input = char ? @fail ! succeed

# end = end_of_input

whitespace = many(space | newline)

ws = whitespace

# word = until(char, whitespace | end_of_input)

# line = until(char, newline | end_of_input)

# digit = number_of(numeral)

# integer = number_of(_number_integer_part)

# int = integer

# float = number_of(_number_integer_part + _number_decimal_part)

# scientific_integer = number_of(_number_integer_part + _number_exponent_part)

# scientific_float = number_of(
#   _number_integer_part +
#   _number_decimal_part +
#   _number_exponent_part
# )

# number = number_of(
#   _number_integer_part +
#   maybe(_number_decimal_part) +
#   maybe(_number_exponent_part)
# )

# num = number

# _number_integer_part =
#   (maybe("-") + "1".."9" + numerals) |
#   (maybe("-") + numeral)

# _number_decimal_part = "." + numerals

# _number_exponent_part = ("e" | "E") + maybe("-" | "+") + numerals

true(t) = t $ true

false(f) = f $ false

boolean(t, f) = true(t) | false(f)

bool = boolean

null(n) = n $ null

# fail = @fail

succeed = ""

# peek(p) = (V <- p) ! const(V)

maybe(p) = p | succeed

skip(p) = p $ ""

nullable(p) = p | const(null)

default(p, D) = p | const(D)

const(C) = succeed $ C

# string_of(p) = V <- p $ StringOf(V)

# number_of(p) = V <- p $ NumberOf(V)

surround(p, fill) = fill > p < fill

# balanced_pairs(open, p, close) =
#  Open <- open & _balanced_pairs_rec(open, p, close, Open, 1)

# _balanced_pairs_rec(open, p, close, Acc, Depth) =
#   0 <- const(Depth) ? const(Acc) :
#   Close <- close ? _matching_pair_rec(open, p, close, Acc + Close, Depth - 1) :
#   Open <- open ? _matching_pair_rec(open, p, close, Acc + Open, Depth + 1) :
#   Next <- p & _matching_pair_rec(open, p, close, Acc + Next, Depth)

# input(p) = surround(p, maybe(whitespace)) < end_of_input

many(p) = p + (many(p) | "")

# many(p) = First <- p & _many_rec(p, First)

# _many_rec(p, Acc) = Next <- p ? _many_rec(p, Acc + Next) : const(Acc)

# until(p, stop) = First <- p & _until_rec(p, stop, First)

# _until_rec(p, stop, Acc) =
#   peek(stop) ?
#   const(Acc) :
#   Next <- p & _until_rec(p, stop, Acc + Next)

# unless(p, excluded) = excluded ? @fail : p

# repeat(p, N) =
#   _assert_positive_integer(N) &
#   First <- p &
#   _repeat_rec(p, N - 1, First)

# _repeat_rec(p, N, Acc) =
#   0 <- const(N) ?
#   const(Acc) :
#   Next <- p & _repeat_rec(p, N - 1, Acc + Next)

# repeat_between(p, L, H) =
#   _assert_positive_integer(L) &
#   _assert_positive_integer(H) &
#   _assert_positive_integer(H - L) &
#   First <- p &
#   _repeat_between_rec(p, L - 1, H, First)

# _repeat_between_rec(p, L, H, Acc) =
#   0 <- const(L) & 0 <- const(H) ? const(Acc) :
#   0 <- const(L) ? Next <- p & _repeat_between_rec(p, L, H - 1, Acc + Next) :
#   Next <- p & _repeat_between_rec(p, L - 1, H, Acc + Next)

scan(p) = p | (char > scan(p))

# array(elem) = First <- elem & _array_rec(elem, [First])

# _array_rec(elem, Acc) =
#   Elem <- elem ?
#   _array_rec(elem, [...Acc, Elem]) :
#   const(Acc)

# array_sep(elem, sep) = First <- elem & _array_sep_rec(elem, sep, [First])

# _array_sep_rec(elem, sep, Acc) =
#   Elem <- sep > elem ?
#   _array_sep_rec(elem, sep, [...Acc, Elem]) :
#   const(Acc)

# array_until(elem, stop) = First <- elem & _array_until_rec(elem, stop, [First])

# _array_until_rec(elem, stop, Acc) =
#   peek(stop) ?
#   const(Acc) :
#   Elem <- elem & _array_until_rec(elem, stop, [...Acc, Elem])

# maybe_array(elem) = default(array(elem), [])

# maybe_array_sep(elem, sep) = default(array_sep(elem, sep), [])

# table_sep(elem, sep, row_sep) =
#   First <- elem & _table_sep_rec(elem, sep, row_sep, [[First]])

# _table_sep_rec(elem, sep, row_sep, Acc) =
#   NextRow <- row_sep > elem ?
#   _table_sep_rec(elem, sep, row_sep, ArrayAppend(Acc [NextRow])) :
#   Elem <- sep > elem ?
#   _table_sep_rec(elem, sep, TableAppend(Acc, Elem)) :
#   const(Acc)

# maybe_table_sep(elem, sep, row_sep) =
#   default(table_sep(elem, sep, row_sep), [[]])

# single(elem) = Elem <- elem $ [Elem]

# pair(elem) = E1 <- elem & E2 <- elem $ [E1, E2]

# pair_sep(elem, sep) = E1 <- elem & sep & E2 <- elem $ [E1, E2]

# triple(elem) = E1 <- elem & E2 <- elem & E3 <- elem $ [E1, E2, E3]

# triple(elem, sep) = E1 <- elem & sep & E2 <- elem & sep & E3 <- elem $ [E1, E2, E3]

# tuple(elem, N) =
#   _assert_positive_integer(N) &
#   First <- elem &
#   _tuple_rec(elem, N - 1, [First])

# _tuple_rec(elem, N, Acc) =
#   0 <- const(N) ?
#   const(Acc) :
#   Elem <- elem & _tuple_rec(elem, N - 1, [...Acc, Elem])

# tuple_sep(elem, sep, N) =
#   _assert_positive_integer(N) &
#   First <- elem &
#   _tuple_sep_rec(elem, sep, N - 1, [First])

# _tuple_sep_rec(elem, sep, N, Acc) =
#   0 <- const(N) ?
#   const(Acc) :
#   Elem <- sep > elem & _tuple_sep_rec(elem, sep, N - 1, [...Acc, Elem])

# object(key, value) =
#   K <- key & V <- value &
#   _object_rec(key, value, {K: V})

# _object_rec(key, value, Acc) =
#   K <- key & V <- value ?
#   object(key, value, {...Acc, K: V}) :
#   const(Acc)

# object_sep(key, pair_sep, value, sep) =
#   K <- key & pair_sep & V <- value &
#   _object_sep_rec(key, pair_sep, value, sep, {K: V})

# _object_sep_rec(key, pair_sep, value, sep, Acc) =
#   sep & K <- key & pair_sep & V <- value ?
#   _object_sep_rec(key, pair_sep, value, sep, {...Acc, K: V}) :
#   const(Acc)

# object_until(key, value, stop) =
#   K <- key & V <- value & _object_until_rec(key, value, stop, {K: V})

# _object_until_rec(key, value, stop, Acc) =
#   peek(stop) ?
#   const(Acc) :
#   K <- key & V <- value & _object_until_rec(key, value, stop, {...Acc, K: V})

# maybe_object(key, value) = default(object(key, value), {})

# maybe_object_sep(key, pair_sep, value, sep) =
#   default(object_sep(key, pair_sep, value, sep), {})

# label(Key, value) = Value <- value $ {Key: Value}

# json_object = "%({...J})" <- matching_pair("{", char, "}") $ J

# json_array = "%([...J])" <- matching_pair("[", char, "]") $ J

# json_string = '"' > _json_string_rec("")

# _json_string_rec(Acc) =
#   '"' ?
#   const(Acc) :
#   Next <- (
#     `\"` $ `"` |
#     `\\` $ `\` |
#     `\/` $ `/` |
#     `\b` $ "\b" |
#     `\f` $ "\f" |
#     `\n` $ "\n" |
#     `\r` $ "\r" |
#     `\t` $ "\t" |
#     _unicode_escape |
#     unless(char, `\`)
#   ) &
#   _json_string_rec(Acc + Next)

# _unicode_escape = `\u` & H <- _hex + _hex + _hex + _hex $ "\u%(H)"

# _hex = digit | "a".."f" | "A".."F"

# json =
#   json_object |
#   json_array |
#   json_string |
#   number |
#   boolean("true", "false") |
#   null("null")

# _assert_positive_integer(V) =
#   N <- const(IsNumber(V)) ? (
#     @run(peek("1".."9") > integer > end, "%(N)") |
#     @error("Expected a positive integer, got `%(N)`.")
#   ) :
#   S <- const(IsString(V)) ?
#   @error('Expected an integer, got string "%(S)".') :
#   @error("Expected an integer, got value `%(V)`.")

# StringOf(V) = "%(V)"

# NumberOf(V) = ("%(0 + N)" <- V) | (0 + N <- V) $ V
