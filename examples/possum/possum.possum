input(program)

program = ast.node(array(w_arround(statement)), $"program")

statement = (named_function | main_parser) < statement_sep

statement_sep = nl | w_arround(";") | w_arround(end)

named_function =
  parser_variable_node | value_variable_node -> Ident & w &
  default(function_args_or_params, []) -> Params & w &
  "=" > expr -> Body $
  { "type": "named_function", "ident": Ident, "params": Params, "body": Body }

main_parser = ast.node(expr, $"main_parser")

comment = "#" > chars_until(nl | end)

w = maybe_many(comment | whitespace)

w_arround(p) = surround(p, w)

# Don't parse trailing whitespace so that we can detect newline expr separators.
expr = ast.with_operator_precedence(
  w > operand,
  w_arround(prefix),
  w_arround(infix),
  w > postfix,
)

operand =
  grouped_expr |
  boolean_node |
  null_node |
  string_node |
  template_string_node |
  number_node |
  parser_variable_node |
  value_variable_node |
  underscore_variable_node |
  array_node |
  object_node

prefix =
  ast.prefix_node("$",   $"value_label",         $9) |
  ast.prefix_node("...", $"spread",              $8) |
  ast.prefix_node("..",  $"upper_bounded_range", $7) |
  ast.prefix_node("-",   $"negate",              $6)

infix =
  ast.infix_node("..", $"range",         $5, $5.5) |
  ast.infix_node("|",  $"or",            $4, $4.5) |
  ast.infix_node(">",  $"take_right",    $4, $4.5) |
  ast.infix_node("<",  $"take_left",     $4, $4.5) |
  ast.infix_node("+",  $"merge",         $4, $4.5) |
  ast.infix_node("!",  $"backtrack",     $4, $4.5) |
  ast.infix_node("->", $"destructure",   $4, $4.5) |
  ast.infix_node("$",  $"return",        $4, $4.5) |
  ast.infix_node("-",  $"subtract",      $4, $4.5) |
  ast.infix_node("*",  $"repeat",        $4, $4.5) |
  ast.infix_node("&",  $"and",           $3, $3.5) |
  conditional_infix(   $"conditional",   $2.5, $2) |
  ast.infix_node("=",  $"assign",        $1.5, $1)

postfix =
  call_function_postfix(      $"call_function",       $11) |
  lower_bounded_range_postfix($"lower_bounded_range", $10)

grouped_expr = "(" > w > expr < w < ")"

boolean_node = ast.node(
  boolean("t" + word -> "true", "f" + word -> "false"),
  $"boolean",
)

null_node = "n" + word -> "null" $ {"type": "null"}

string_node = ast.node(
  surround(quoted_string_body(`"`), `"`) |
  surround(quoted_string_body(`'`), `'`) |
  surround(backtick_string_body, "`"),
  $"string",
)

quoted_string_body(end_quote) =
  many(
    string_escape_char |
    string_escape_unicode |
    unless(char, `\` | `%(` | end_quote)
  ) |
  const($"")

string_escape_char =
  `\0` | `\b` | `\t` | `\n` | `\v` | `\f` | `\r` | `\'` | `\"` | `\\`

string_escape_unicode = `\u` + (hex_numeral * 6)

backtick_string_body = chars_until("`") | const($"")

template_string_node = ast.node(
  surround(template_string_body(`"`, [], $""), `"`) |
  surround(template_string_body(`'`, [], $""), `'`),
  $"template_string",
)

template_string_body(end_quote, TemplateParts, Str) =
  peek(end_quote) ? const(AppendNonEmptyString(TemplateParts, Str)) :
  `%(` > w < `)` ? template_string_body(end_quote, TemplateParts, Str) :
  `%(` ? (
    w_arround(expr) -> Expr & ")" &
    template_string_body(
      end_quote,
      [...AppendNonEmptyString(TemplateParts, Str), Expr],
      $""
    )
  ) :
  string_escape_char | string_escape_unicode | unless(char, `\`) -> Next &
  template_string_body(end_quote, TemplateParts, Str + Next)

AppendNonEmptyString(TemplateParts, Str) =
  Str -> "" ? TemplateParts : [...TemplateParts, {"type": "string", "value": Str}]

number_node = ast.node(number, $"number")

variable_node(Type, name_format) =
  peek(tuple2(
    boolean("@", succeed),
    boolean(many("_"), succeed)
  )) -> [IsMeta, IsUnderscored] &
  maybe("@") + maybe_many("_") + name_format -> Name $
  {
    "type": Type,
    "name": Name,
    "is_meta": IsMeta,
    "is_underscored": IsUnderscored,
  }

parser_variable_node = variable_node($"parser_variable", lower + maybe_many(alnum | "_" | "."))

value_variable_node = variable_node($"value_variable", upper + maybe_many(alpha | "_" | "."))

underscore_variable_node = ast.node(many("_"), $"underscore_variable")

array_node = ast.node(
  "[" > w > maybe_array_sep(expr, ",") < trailing_comma < "]",
  $"array",
)

object_node = ast.node(
  "{" > w > maybe_array_sep(object_pair, ",") < trailing_comma < "}",
  $"object",
)

object_pair = tuple2_sep(w_arround(expr), ":", w_arround(expr))

function_args_or_params =
  "(" > w > maybe_array_sep(w_arround(expr), ",") < trailing_comma < ")"

trailing_comma = maybe(w_arround(","))

conditional_infix(Type, LeftBindingPower, RightBindingPower) =
  "?" & w & expr -> Middle & w & ":" $
  {"type": Type, "middle": Middle, "power": [LeftBindingPower, RightBindingPower]}

# Since ".." can be a prefix, infix, or postfix we need to make sure it isn't
# parsed as postfix when it is intended as infix. To do this we look ahead to
# make sure there isn't a right hand value, and if there is we fail in order to
# parse as infix instead.
lower_bounded_range_postfix(Type, BindingPower) =
  ".." & peek(w > (postfix | infix | end)) $
  {"type": Type, "power": BindingPower}

call_function_postfix(Type, BindingPower) =
  function_args_or_params -> Args $
  {"type": Type, "args": Args, "power": BindingPower}
